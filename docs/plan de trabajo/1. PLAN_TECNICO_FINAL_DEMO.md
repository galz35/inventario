# Plan de Ejecuci√≥n T√©cnica: Ajuste Final Enterprise (INVCORE V1)
> Documento vivo con c√≥digo listo para implementaci√≥n. Cubre Auditor√≠a, UX Avanzado y Finanzas.

---

## üìÖ Fase 1: Auditor√≠a Inmutable (Base de Datos)
**Objetivo:** Implementar "Cajas Negras" en SQL Server. Si el stock cambia, queda huella forense.

### 1.1 Script SQL: Auditor√≠a de Stock (`backend/src/db/scripts/AUDITORIA_TRIGGERS.sql`)
```sql
USE inventario;
GO

-- 1. Tabla Hist√≥rica (Espejo)
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'Inv_sis_auditoria_stock') AND type in (N'U'))
BEGIN
    CREATE TABLE Inv_sis_auditoria_stock (
        idAuditoria INT IDENTITY(1,1) PRIMARY KEY,
        almacenId INT,
        productoId INT,
        cantidadAnterior DECIMAL(18,2),
        cantidadNueva DECIMAL(18,2),
        diferencia AS (cantidadNueva - cantidadAnterior),
        fechaCambio DATETIME DEFAULT GETDATE(),
        usuarioDB NVARCHAR(100) DEFAULT SYSTEM_USER,
        hostName NVARCHAR(100) DEFAULT HOST_NAME()
    );
END
GO

-- 2. Trigger de Actualizaci√≥n
CREATE OR ALTER TRIGGER Inv_trg_auditoria_stock
ON Inv_inv_stock
AFTER UPDATE
AS
BEGIN
    SET NOCOUNT ON;
    
    INSERT INTO Inv_sis_auditoria_stock (almacenId, productoId, cantidadAnterior, cantidadNueva)
    SELECT 
        i.almacenId,
        i.productoId,
        d.cantidad, -- deleted (valor anterior)
        i.cantidad  -- inserted (valor nuevo)
    FROM inserted i
    JOIN deleted d ON i.almacenId = d.almacenId AND i.productoId = d.productoId
    WHERE i.cantidad <> d.cantidad; -- Solo si hubo cambio real
END
GO
```

---

## üìÖ Fase 2: Experiencia de Usuario (Rastreador de Series)
**Objetivo:** "Google" para tus activos fijos.

### 2.1 Backend Repo (`backend/src/inv_modules/activos/activos.repo.ts`)
```typescript
/**
 * B√∫squeda Inteligente de Activo por Serial
 */
export async function buscarActivoPorSerie(serial: string) {
    // Busca coincidencia parcial o exacta
    return await ejecutarQuery(`
        SELECT TOP 1
            a.idActivo,
            a.serial,
            a.estado,
            p.nombre as productoNombre,
            p.codigo as productoCodigo,
            alm.nombre as ubicacionAlmacen,
            u.nombre as tecnicoResponsable,
            c.nombre as clienteAsignado,
            a.fechaIngreso
        FROM Inv_act_activos a
        JOIN Inv_cat_productos p ON a.idProducto = p.idProducto
        LEFT JOIN Inv_cat_almacenes alm ON a.idAlmacenActual = alm.idAlmacen
        LEFT JOIN Inv_seg_usuarios u ON a.idTecnicoActual = u.idUsuario
        LEFT JOIN Inv_cat_clientes c ON a.idClienteActual = c.idCliente
        WHERE a.serial LIKE @serial
    `, { serial: { valor: `%${serial}%`, tipo: NVarChar } });
}
```

### 2.2 Frontend View (`frontend/src/modules/activos/ActivosView.tsx`)
*Snippet para la barra de b√∫squeda:*
```tsx
const [busqueda, setBusqueda] = useState('');
const [activoEncontrado, setActivoEncontrado] = useState<any>(null);

const handleSearch = async (e: React.FormEvent) => {
    e.preventDefault();
    if(!busqueda) return;
    try {
        const res = await api.get(`/inv/activos/buscar?serial=${busqueda}`);
        if(res.data) setActivoEncontrado(res.data);
        else alertWarning('No se encontr√≥ el activo');
    } catch(err) { console.error(err); }
};

// Renderizado de Tarjeta
{activoEncontrado && (
    <div className="card-result" style={{ borderLeft: '4px solid var(--primary)' }}>
        <h3>{activoEncontrado.productoNombre}</h3>
        <div className="badge">{activoEncontrado.estado}</div>
        <p>üìç Ubicaci√≥n: {activoEncontrado.ubicacionAlmacen || activoEncontrado.tecnicoResponsable || 'Desconocida'}</p>
        <p>üÜî Serial: {activoEncontrado.serial}</p>
    </div>
)}
```

---

## üìÖ Fase 3: Transparencia (Kardex Visual)
**Objetivo:** L√≠nea de tiempo estilo "Tracking de Paquete".

### 3.1 Backend: Consulta Hist√≥rica (`backend/src/inv_modules/inventario/inventario.repo.ts`)
```typescript
export async function obtenerHistoriaProducto(productoId: number, almacenId: number) {
    return await ejecutarQuery(`
        SELECT 
            m.fechaMovimiento,
            m.tipoMovimiento,
            m.referenciaTexto,
            md.cantidad,
            md.stockNuevo as saldo,
            u.nombre as usuario
        FROM Inv_inv_movimientos m
        JOIN Inv_inv_movimiento_detalle md ON m.idMovimiento = md.idMovimiento
        JOIN Inv_seg_usuarios u ON m.idUsuarioResponsable = u.idUsuario
        WHERE md.productoId = @prodId 
          AND (m.almacenOrigenId = @almId OR m.almacenDestinoId = @almId)
        ORDER BY m.fechaMovimiento DESC
    `, { 
        prodId: { valor: productoId, tipo: Int },
        almId: { valor: almacenId, tipo: Int }
    });
}
```

---

## üìÖ Fase 4: Sem√°foro de Stock (Validaci√≥n Preventiva)
**Objetivo:** Evitar OTs con materiales fantasma.

### 4.1 Backend Validation (`backend/src/inv_modules/operaciones/operaciones.repo.ts`)
```typescript
// Insertar antes de registrar consumo
export async function validarStockDisponible(almacenId: number, items: any[]) {
    for (const item of items) {
        const stock = await ejecutarQuery(`
            SELECT cantidad FROM Inv_inv_stock 
            WHERE almacenId = @alm AND productoId = @prod
        `, { alm: {valor: almacenId, tipo: Int}, prod: {valor: item.productoId, tipo: Int} });
        
        const disponible = stock[0]?.cantidad || 0;
        if (disponible < item.cantidad) {
            throw new Error(`Stock insuficiente para producto ID ${item.productoId}. Disp: ${disponible}, Req: ${item.cantidad}`);
        }
    }
}
```

---

## üìÖ Fase 5: Reporte Financiero (Consignaci√≥n)
**Objetivo:** Finanzas sin dolor.

### 5.1 Vista SQL (`backend/src/db/scripts/REPORTE_FINANCIERO.sql`)
```sql
CREATE OR ALTER VIEW Inv_vw_liquidacion_consignacion_mes AS
SELECT 
    prov.nombre as Proveedor,
    p.nombre as Material,
    SUM(ABS(otc.cantidad)) as CantidadConsumida,
    p.costo as CostoUnitario,
    SUM(ABS(otc.cantidad) * p.costo) as TotalPagar,
    MONTH(otc.fechaConsumo) as Mes,
    YEAR(otc.fechaConsumo) as Anio
FROM Inv_ope_ot_consumo otc
JOIN Inv_ope_ot ot ON otc.idOT = ot.idOT
JOIN Inv_cat_productos p ON otc.productoId = p.idProducto
JOIN Inv_inv_movimiento_detalle md ON otc.idMovimientoInventario = md.idMovimiento
JOIN Inv_cat_proveedores prov ON md.proveedorId = prov.idProveedor
WHERE md.propietarioTipo = 'PROVEEDOR'
GROUP BY prov.nombre, p.nombre, p.costo, MONTH(otc.fechaConsumo), YEAR(otc.fechaConsumo);
GO
```

---

## ‚úÖ Checklist de Ejecuci√≥n (Orden de Batalla)

1.  [ ] **Ejecutar SQL Triggers:** Copiar script 1.1 -> Ejecutar en DB. (Blindaje inmediato).
2.  [ ] **Ejecutar SQL Vistas:** Copiar script 5.1 -> Ejecutar en DB. (Listos para reportes).
3.  [ ] **Backend Update:** Pegar funciones en `activos.repo.ts` y `operaciones.repo.ts`.
4.  [ ] **Frontend Update:** Crear vista `ActivosView` con el buscador.
5.  [ ] **Frontend Update:** Agregar sem√°foro visual en el modal de OT.

Este documento ahora es **EJECUTABLE**. Contiene el c√≥digo exacto necesario.
